// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: quotes.sql

package postgres

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const countQuotes = `-- name: CountQuotes :one
SELECT COUNT(*) FROM quotes
`

func (q *Queries) CountQuotes(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countQuotes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createQuote = `-- name: CreateQuote :one
INSERT INTO quotes (
    content, author_id, source, tags
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, content, author_id, source, tags, created_at, updated_at
`

type CreateQuoteParams struct {
	Content  string         `json:"content"`
	AuthorID int64          `json:"author_id"`
	Source   sql.NullString `json:"source"`
	Tags     []string       `json:"tags"`
}

func (q *Queries) CreateQuote(ctx context.Context, arg CreateQuoteParams) (Quote, error) {
	row := q.db.QueryRowContext(ctx, createQuote,
		arg.Content,
		arg.AuthorID,
		arg.Source,
		pq.Array(arg.Tags),
	)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.AuthorID,
		&i.Source,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteQuote = `-- name: DeleteQuote :exec
DELETE FROM quotes
WHERE id = $1
`

func (q *Queries) DeleteQuote(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteQuote, id)
	return err
}

const getQuote = `-- name: GetQuote :one
SELECT 
    q.id, q.content, q.author_id, q.source, q.tags, q.created_at, q.updated_at,
    a.id as author_id,
    a.name as author_name,
    a.bio as author_bio,
    a.created_at as author_created_at,
    a.updated_at as author_updated_at
FROM quotes q
JOIN authors a ON q.author_id = a.id
WHERE q.id = $1 LIMIT 1
`

type GetQuoteRow struct {
	ID              int64          `json:"id"`
	Content         string         `json:"content"`
	AuthorID        int64          `json:"author_id"`
	Source          sql.NullString `json:"source"`
	Tags            []string       `json:"tags"`
	CreatedAt       time.Time      `json:"created_at"`
	UpdatedAt       time.Time      `json:"updated_at"`
	AuthorID_2      int64          `json:"author_id_2"`
	AuthorName      string         `json:"author_name"`
	AuthorBio       sql.NullString `json:"author_bio"`
	AuthorCreatedAt time.Time      `json:"author_created_at"`
	AuthorUpdatedAt time.Time      `json:"author_updated_at"`
}

func (q *Queries) GetQuote(ctx context.Context, id int64) (GetQuoteRow, error) {
	row := q.db.QueryRowContext(ctx, getQuote, id)
	var i GetQuoteRow
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.AuthorID,
		&i.Source,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuthorID_2,
		&i.AuthorName,
		&i.AuthorBio,
		&i.AuthorCreatedAt,
		&i.AuthorUpdatedAt,
	)
	return i, err
}

const getRandomQuote = `-- name: GetRandomQuote :one
SELECT 
    q.id, q.content, q.author_id, q.source, q.tags, q.created_at, q.updated_at,
    a.id as author_id,
    a.name as author_name,
    a.bio as author_bio,
    a.created_at as author_created_at,
    a.updated_at as author_updated_at
FROM quotes q
JOIN authors a ON q.author_id = a.id
ORDER BY RANDOM()
LIMIT 1
`

type GetRandomQuoteRow struct {
	ID              int64          `json:"id"`
	Content         string         `json:"content"`
	AuthorID        int64          `json:"author_id"`
	Source          sql.NullString `json:"source"`
	Tags            []string       `json:"tags"`
	CreatedAt       time.Time      `json:"created_at"`
	UpdatedAt       time.Time      `json:"updated_at"`
	AuthorID_2      int64          `json:"author_id_2"`
	AuthorName      string         `json:"author_name"`
	AuthorBio       sql.NullString `json:"author_bio"`
	AuthorCreatedAt time.Time      `json:"author_created_at"`
	AuthorUpdatedAt time.Time      `json:"author_updated_at"`
}

func (q *Queries) GetRandomQuote(ctx context.Context) (GetRandomQuoteRow, error) {
	row := q.db.QueryRowContext(ctx, getRandomQuote)
	var i GetRandomQuoteRow
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.AuthorID,
		&i.Source,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuthorID_2,
		&i.AuthorName,
		&i.AuthorBio,
		&i.AuthorCreatedAt,
		&i.AuthorUpdatedAt,
	)
	return i, err
}

const listQuotes = `-- name: ListQuotes :many
SELECT 
    q.id, q.content, q.author_id, q.source, q.tags, q.created_at, q.updated_at,
    a.id as author_id,
    a.name as author_name,
    a.bio as author_bio,
    a.created_at as author_created_at,
    a.updated_at as author_updated_at
FROM quotes q
JOIN authors a ON q.author_id = a.id
ORDER BY q.created_at DESC
LIMIT $1 OFFSET $2
`

type ListQuotesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListQuotesRow struct {
	ID              int64          `json:"id"`
	Content         string         `json:"content"`
	AuthorID        int64          `json:"author_id"`
	Source          sql.NullString `json:"source"`
	Tags            []string       `json:"tags"`
	CreatedAt       time.Time      `json:"created_at"`
	UpdatedAt       time.Time      `json:"updated_at"`
	AuthorID_2      int64          `json:"author_id_2"`
	AuthorName      string         `json:"author_name"`
	AuthorBio       sql.NullString `json:"author_bio"`
	AuthorCreatedAt time.Time      `json:"author_created_at"`
	AuthorUpdatedAt time.Time      `json:"author_updated_at"`
}

func (q *Queries) ListQuotes(ctx context.Context, arg ListQuotesParams) ([]ListQuotesRow, error) {
	rows, err := q.db.QueryContext(ctx, listQuotes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListQuotesRow{}
	for rows.Next() {
		var i ListQuotesRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.AuthorID,
			&i.Source,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorID_2,
			&i.AuthorName,
			&i.AuthorBio,
			&i.AuthorCreatedAt,
			&i.AuthorUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuotesByAuthor = `-- name: ListQuotesByAuthor :many
SELECT 
    q.id, q.content, q.author_id, q.source, q.tags, q.created_at, q.updated_at,
    a.id as author_id,
    a.name as author_name,
    a.bio as author_bio,
    a.created_at as author_created_at,
    a.updated_at as author_updated_at
FROM quotes q
JOIN authors a ON q.author_id = a.id
WHERE q.author_id = $1
ORDER BY q.created_at DESC
LIMIT $2 OFFSET $3
`

type ListQuotesByAuthorParams struct {
	AuthorID int64 `json:"author_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

type ListQuotesByAuthorRow struct {
	ID              int64          `json:"id"`
	Content         string         `json:"content"`
	AuthorID        int64          `json:"author_id"`
	Source          sql.NullString `json:"source"`
	Tags            []string       `json:"tags"`
	CreatedAt       time.Time      `json:"created_at"`
	UpdatedAt       time.Time      `json:"updated_at"`
	AuthorID_2      int64          `json:"author_id_2"`
	AuthorName      string         `json:"author_name"`
	AuthorBio       sql.NullString `json:"author_bio"`
	AuthorCreatedAt time.Time      `json:"author_created_at"`
	AuthorUpdatedAt time.Time      `json:"author_updated_at"`
}

func (q *Queries) ListQuotesByAuthor(ctx context.Context, arg ListQuotesByAuthorParams) ([]ListQuotesByAuthorRow, error) {
	rows, err := q.db.QueryContext(ctx, listQuotesByAuthor, arg.AuthorID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListQuotesByAuthorRow{}
	for rows.Next() {
		var i ListQuotesByAuthorRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.AuthorID,
			&i.Source,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorID_2,
			&i.AuthorName,
			&i.AuthorBio,
			&i.AuthorCreatedAt,
			&i.AuthorUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchQuotesByContent = `-- name: SearchQuotesByContent :many
SELECT 
    q.id, q.content, q.author_id, q.source, q.tags, q.created_at, q.updated_at,
    a.id as author_id,
    a.name as author_name,
    a.bio as author_bio,
    a.created_at as author_created_at,
    a.updated_at as author_updated_at
FROM quotes q
JOIN authors a ON q.author_id = a.id
WHERE q.content ILIKE '%' || $1 || '%'
ORDER BY q.created_at DESC
LIMIT $2 OFFSET $3
`

type SearchQuotesByContentParams struct {
	Column1 sql.NullString `json:"column_1"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

type SearchQuotesByContentRow struct {
	ID              int64          `json:"id"`
	Content         string         `json:"content"`
	AuthorID        int64          `json:"author_id"`
	Source          sql.NullString `json:"source"`
	Tags            []string       `json:"tags"`
	CreatedAt       time.Time      `json:"created_at"`
	UpdatedAt       time.Time      `json:"updated_at"`
	AuthorID_2      int64          `json:"author_id_2"`
	AuthorName      string         `json:"author_name"`
	AuthorBio       sql.NullString `json:"author_bio"`
	AuthorCreatedAt time.Time      `json:"author_created_at"`
	AuthorUpdatedAt time.Time      `json:"author_updated_at"`
}

func (q *Queries) SearchQuotesByContent(ctx context.Context, arg SearchQuotesByContentParams) ([]SearchQuotesByContentRow, error) {
	rows, err := q.db.QueryContext(ctx, searchQuotesByContent, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchQuotesByContentRow{}
	for rows.Next() {
		var i SearchQuotesByContentRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.AuthorID,
			&i.Source,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorID_2,
			&i.AuthorName,
			&i.AuthorBio,
			&i.AuthorCreatedAt,
			&i.AuthorUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateQuote = `-- name: UpdateQuote :one
UPDATE quotes
SET 
    content = $2,
    author_id = $3,
    source = $4,
    tags = $5
WHERE id = $1
RETURNING id, content, author_id, source, tags, created_at, updated_at
`

type UpdateQuoteParams struct {
	ID       int64          `json:"id"`
	Content  string         `json:"content"`
	AuthorID int64          `json:"author_id"`
	Source   sql.NullString `json:"source"`
	Tags     []string       `json:"tags"`
}

func (q *Queries) UpdateQuote(ctx context.Context, arg UpdateQuoteParams) (Quote, error) {
	row := q.db.QueryRowContext(ctx, updateQuote,
		arg.ID,
		arg.Content,
		arg.AuthorID,
		arg.Source,
		pq.Array(arg.Tags),
	)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.AuthorID,
		&i.Source,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
